<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Navigator (Fullscreen)</title>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Custom CSS for Game Aesthetics -->
    <style>
        /* Make the game truly fullscreen */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Hide scrollbars */
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        /* Game container now fills the entire page */
        #game-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Overlay panel for info and controls */
        #info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(33, 33, 33, 0.85);
            backdrop-filter: blur(5px);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 300px;
            z-index: 10;
            /* Starts hidden, toggled by JS */
            display: none; 
        }

        #info-overlay h2 {
            margin-top: 0;
            font-size: 1.15rem;
            color: #4CAF50; /* Green highlight */
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }

        #info-overlay p {
            margin: 10px 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .key {
            display: inline-block;
            padding: 4px 9px;
            margin: 0 2px;
            background-color: #555;
            border-radius: 4px;
            border-bottom: 2px solid #333;
            font-family: monospace;
            font-weight: bold;
            font-size: 0.95rem;
        }

        /* Buttons for toggling info and fullscreen */
        .control-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, box-shadow 0.2s;
            z-index: 11;
        }

        .control-button:hover {
            background-color: #45a049;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        /* Position the info toggle button next to the fullscreen button */
        #toggle-info-btn {
            right: 155px; /* Adjust as needed */
            background-color: #555;
        }
        #toggle-info-btn:hover {
            background-color: #666;
        }

    </style>
</head>
<body>

    <!-- The game canvas will be put here -->
    <div id="game-container"></div>

    <!-- UI Buttons -->
    <button id="fullscreen-btn" class="control-button">Fullscreen</button>
    <button id="toggle-info-btn" class="control-button">Show Controls</button>

    <!-- Info panel is now an overlay -->
    <div id="info-overlay">
        <h2>3D Cube Navigator</h2>
        <p>Explore the flat forest and the mysterious house.</p>
        <p>
            <span class="key">W</span> / <span class="key">&uarr;</span> (Forward) <br>
            <span class="key">S</span> / <span class="key">&darr;</span> (Backward) <br>
            <span class="key">A</span> / <span class="key">&larr;</span> (Left) <br>
            <span class="key">D</span> / <span class="key">&rarr;</span> (Right) <br>
            <span class="key">SPACE</span> (Jump)
        </p>
    </div>

    <script>
        // Global variables for Three.js
        let scene, camera, renderer;
        let playerCube;
        const movementSpeed = 0.1;
       
        // Constants for the Terrain
        const planeSize = 100;
        const planeSegments = 50;
        const groundYLevel = 0; // Flat ground level

        // House and Interior Global References
        let houseExteriorWalls; // Reference to the main walls mesh for toggling visibility
        let houseDoor;          // Reference to the door mesh (stays visible)
        let interiorGroup;      // The group containing the furniture and interior walls
        let isInside = false;   // State variable for collision

        // Physics variables for jumping
        let velocityY = 0;
        const gravity = -0.02; // Downward acceleration
        const jumpStrength = 0.5; // Initial upward velocity

        // Updated keys object to track state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // --- COLLISION CONSTANTS (Player Center Coordinates) ---
        // House is 6x6. Player is 1x1x1 (radius 0.5).
        const COLLISION_X_MIN = -2.5; // Left Wall (-3 + 0.5)
        const COLLISION_X_MAX = 2.5;  // Right Wall (3 - 0.5)
        const COLLISION_Z_MIN = -2.5; // Back Wall (-3 + 0.5)
        const COLLISION_Z_MAX = 2.5;  // Front Wall (3 - 0.5)

        // Door X bounds (Player center must be within this range to pass through the Z=3 barrier)
        const DOOR_X_MIN = -0.5;
        const DOOR_X_MAX = 0.5;
        // --------------------------------------------------------


        // --- Utility Function: Calculate ground height at given (x, z) ---
        function getHeight(x, z) {
            // This is simplified for a flat world, but could be complex
            return groundYLevel;
        }

        // --- Utility Function: Create a simple tree model ---
        function createTree(x, z) {
            // Trunk (Brown Cylinder)
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

            // Canopy (Green Cone)
            const canopyGeometry = new THREE.ConeGeometry(1.5, 3, 8);
            const canopyMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
           
            const tree = new THREE.Group();
            tree.add(trunk);
            tree.add(canopy);

            canopy.position.y = 2.5;
            tree.position.set(x, groundYLevel + 1, z);

            return tree;
        }

        // --- Utility Function: Create the house interior ---
        function createInterior(x, z) {
            const interior = new THREE.Group();
            const roomWidth = 6;
            const roomDepth = 6;
            const roomHeight = 5;

            // Interior Floor (Brown wood color)
            const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x5C4033, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = 0.01;

            // Interior Wall Material (Light paint color)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xeee8aa, side: THREE.DoubleSide });

            // Back wall
            const backWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, roomHeight / 2, -roomDepth / 2);

            // Right side wall
            const sideWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
            const sideWallRight = new THREE.Mesh(sideWallGeometry, wallMaterial.clone());
            sideWallRight.rotation.y = Math.PI / 2;
            sideWallRight.position.set(roomWidth / 2, roomHeight / 2, 0);
           
            // Left side wall
            const sideWallLeft = new THREE.Mesh(sideWallGeometry, wallMaterial.clone());
            sideWallLeft.rotation.y = -Math.PI / 2;
            sideWallLeft.position.set(-roomWidth / 2, roomHeight / 2, 0);

            // Simple table
            const tableGeometry = new THREE.BoxGeometry(2, 1, 1);
            const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(0, 0.5, -1.5); // Placed against the back wall

            interior.add(floor, backWall, sideWallRight, sideWallLeft, table);

            // Position the interior at the house location
            interior.position.set(x, groundYLevel, z);
            return interior;
        }


        // --- Utility Function: Create a simple house model ---
        function createHouse(x, z) {
            const houseGroup = new THREE.Group();
            const wallWidth = 6;
            const wallDepth = 6;
            const wallHeight = 5;
           
            // 1. Walls (Box) - This will be toggled off when inside
            const wallGeometry = new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown wood color
            houseExteriorWalls = new THREE.Mesh(wallGeometry, wallMaterial);
            houseExteriorWalls.position.y = wallHeight / 2;

            // 2. Roof (Cone) - Stays visible
            const roofRadius = wallWidth / 1.5;
            const roofHeight = 3;
            const roofGeometry = new THREE.ConeGeometry(roofRadius, roofHeight, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xA52A2A });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.y = Math.PI / 4;
            roof.position.y = wallHeight + roofHeight / 2;

            // 3. Door (Narrow Box) - Stays visible
            const doorGeometry = new THREE.BoxGeometry(1, 2.5, 0.1);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x5C3317 });
            houseDoor = new THREE.Mesh(doorGeometry, doorMaterial);
            houseDoor.position.set(0, 2.5 / 2, wallDepth / 2 + 0.05);

            // Add all exterior parts to the group
            houseGroup.add(houseExteriorWalls);
            houseGroup.add(roof);
            houseGroup.add(houseDoor);

            // Create and add the interior group (starts hidden)
            interiorGroup = createInterior(x, z);
            interiorGroup.visible = false;
            scene.add(interiorGroup);

            houseGroup.position.set(x, groundYLevel, z);
            return houseGroup;
        }


        // --- Initialization Function ---
        function init() {
            const container = document.getElementById('game-container');
            // Use window's inner dimensions for fullscreen
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3a3a3a); // Dark background

            // 2. Camera Setup (Perspective)
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
           
            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // 4. Create the Flat Terrain
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, planeSegments, planeSegments);
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x6B8E23, side: THREE.DoubleSide, flatShading: true });
            const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
           
            groundPlane.rotation.x = Math.PI / 2;
            groundPlane.position.y = groundYLevel;
            scene.add(groundPlane);

            // 5. Add House in the Center
            scene.add(createHouse(0, 0)); // Note: createHouse adds the interiorGroup to the scene too

            // 6. Add Player Cube
            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            playerCube = new THREE.Mesh(playerGeometry, playerMaterial);
           
            playerCube.position.set(0, groundYLevel + 0.5, 10);
            scene.add(playerCube);

            // 7. Add Trees (Forest)
            const treeCount = 30;
            for (let i = 0; i < treeCount; i++) {
                // Spread trees out, avoiding the immediate house area
                let x = (Math.random() - 0.5) * 60;
                let z = (Math.random() - 0.5) * 60;
                if (Math.abs(x) < 8 && Math.abs(z) < 8) {
                    x += Math.sign(x) * 8; // Push them away from center
                }
                scene.add(createTree(x, z));
            }

            // 8. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(20, 30, 15);
            scene.add(directionalLight);
           
            // 9. Grid Helper
            const gridHelper = new THREE.GridHelper(planeSize, planeSegments, 0xaaaaaa, 0x555555);
            gridHelper.position.y = groundYLevel - 0.01;
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // 10. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            // Listeners for new UI buttons
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            document.getElementById('toggle-info-btn').addEventListener('click', toggleInfoPanel);
        }

        // --- Handle window resize for responsiveness ---
        function onWindowResize() {
            // Use window dimensions
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        // --- Fullscreen API Handler ---
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    // console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        // --- Info Panel Toggle ---
        function toggleInfoPanel() {
            const panel = document.getElementById('info-overlay');
            const button = document.getElementById('toggle-info-btn');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
                button.textContent = 'Show Controls';
            } else {
                panel.style.display = 'block';
                button.textContent = 'Hide Controls';
            }
        }

        // --- Input Handling (Key Press/Release) ---
        function onKeyDown(event) {
            // Check event.key for modern browsers
            switch (event.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys.w = true;
                    break;
                case 'a':
                case 'arrowleft':
                    keys.a = true;
                    break;
                case 's':
                case 'arrowdown':
                    keys.s = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys.d = true;
                    break;
                case ' ': // Spacebar for jumping
                    const stableY = groundYLevel + 0.5;
                    // Allow jumping if on the ground or on the roof
                    if (Math.abs(playerCube.position.y - stableY) < 0.05 || Math.abs(playerCube.position.y - 5.5) < 0.05) {
                        velocityY = jumpStrength;
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys.w = false;
                    break;
                case 'a':
                case 'arrowleft':
                    keys.a = false;
                    break;
                case 's':
                case 'arrowdown':
                    keys.s = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys.d = false;
                    break;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            let deltaX = 0;
            let deltaZ = 0;

            // 1. Calculate intended movement deltas based on key states
            if (keys.w) {
                deltaZ -= movementSpeed;
            }
            if (keys.s) {
                deltaZ += movementSpeed;
            }
            if (keys.a) {
                deltaX -= movementSpeed;
            }
            if (keys.d) {
                deltaX += movementSpeed;
            }
           
            // Calculate potential next position
            const nextX = playerCube.position.x + deltaX;
            const nextZ = playerCube.position.z + deltaZ;


            // 2. WALL COLLISION CHECK (Only when outside the house)
            if (!isInside) {
                // Check if player is near the house area (optimization)
                if (nextX > -5 && nextX < 5 && nextZ > -5 && nextZ < 5) {
                   
                    // --- X-AXIS COLLISION (Left/Right Walls) ---
                    // If moving left and hitting the left wall
                    if (nextX < COLLISION_X_MIN) {
                        deltaX = 0;
                        playerCube.position.x = COLLISION_X_MIN;
                    }
                    // If moving right and hitting the right wall
                    else if (nextX > COLLISION_X_MAX) {
                        deltaX = 0;
                        playerCube.position.x = COLLISION_X_MAX;
                    }
                   
                    // --- Z-AXIS COLLISION (Back Wall) ---
                    // If moving backward (S) and hitting the back wall
                    if (nextZ < COLLISION_Z_MIN) {
                        deltaZ = 0;
                        playerCube.position.z = COLLISION_Z_MIN;
                    }
                   
                    // --- Z-AXIS COLLISION (Front Wall & Door) ---
                    // If moving forward (W) and hitting the front wall boundary
                    else if (nextZ > COLLISION_Z_MAX) {
                        // Check if the collision point is outside the door opening
                        if (nextX < DOOR_X_MIN || nextX > DOOR_X_MAX) {
                            deltaZ = 0;
                            playerCube.position.z = COLLISION_Z_MAX;
                        }
                        // If the player is within the DOOR_X range, deltaZ is kept, allowing entry.
                    }
                }
            }
           
            // 3. Apply the (possibly adjusted) movement
            playerCube.position.x += deltaX;
            playerCube.position.z += deltaZ;
           

            // 4. JUMPING AND VERTICAL PHYSICS UPDATE
            velocityY += gravity;
            playerCube.position.y += velocityY;

            const stableY = groundYLevel + 0.5; // Ground landing Y (0.5)
            const roofLandingY = 5.5;          // Roof landing Y (Center of player cube when standing on 5-unit wall)

            const playerX = playerCube.position.x;
            const playerZ = playerCube.position.z;

            const isOverRoofArea = (
                playerX > -3 && playerX < 3 && // Within 6x6 footprint of the house
                playerZ > -3 && playerZ < 3
            );

            // A. ROOF COLLISION CHECK (Prioritized)
            // We added !isInside here so you only land on the roof if you are outside the house.
            if (velocityY <= 0 && isOverRoofArea && !isInside) {
                // If the player passed through the roof landing plane (5.5)
                if (playerCube.position.y <= roofLandingY) {
                    playerCube.position.y = roofLandingY;
                    velocityY = 0;
                }
            }

            // B. GROUND COLLISION CHECK (Fallback)
            // Only check for ground if player is below the ground level (stableY)
            if (playerCube.position.y < stableY) {
                playerCube.position.y = stableY;
                velocityY = 0;
            }
           
            // 5. INTERIOR/EXTERIOR VISIBILITY TOGGLE LOGIC
            // Door Entrance Zone (Threshold check is crucial for triggering entry/exit)
            const isNearDoor = (
                playerX > -1.0 && playerX < 1.0 &&
                playerZ > 2.0 && playerZ < 3.5      
            );

            // House Interior Area (player is inside the box)
            const isInsideWalls = (
                playerX > -3 && playerX < 3 &&
                playerZ > -3 && playerZ < 3
            );

            if (isNearDoor && !isInside) {
                // Entering
                isInside = true;
                houseExteriorWalls.visible = false;
                interiorGroup.visible = true;
            } else if (!isNearDoor && isInside && !isInsideWalls) {
                // Exiting (player is outside the threshold area and is definitely outside the main wall volume)
                if (playerZ > 3.5 || playerZ < -3.5 || playerX > 3.5 || playerX < -3.5) {
                    isInside = false;
                    houseExteriorWalls.visible = true;
                    interiorGroup.visible = false;
                }
            }


            // 6. Make the camera follow the player cube
            const cameraOffset = new THREE.Vector3(0, 5, 5);
            const playerPos = playerCube.position;

            camera.position.x = playerPos.x + cameraOffset.x;
            camera.position.y = playerPos.y + cameraOffset.y + 0.5;
            camera.position.z = playerPos.z + cameraOffset.z;

            camera.lookAt(playerPos.x, playerPos.y, playerPos.z);

            // 7. Render the scene
            renderer.render(scene, camera);
        }

        // Start the game initialization and the animation loop on window load
        window.onload = function () {
            init();
            animate();
        }
    </script>
</body>
</html>
